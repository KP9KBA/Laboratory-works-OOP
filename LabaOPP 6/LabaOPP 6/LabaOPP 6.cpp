#include <iostream>
#include <string>
#include "stdio.h"
#include <ctime>
#include <windows.h>
#include <math.h>
#include <string>//11
using namespace std;

//number 1
void reversit(char s[]) {
int len = strlen(s);        //найти длину строки
for (int j = 0; j < len / 2; j++) {
	char temp = s[j];        //на символы
	s[j] = s[len - j - 1];     //из второй половины
	s[len - j - 1] = temp;
	}
};
//number 2
class employee {
private:
	string name;
	long number;
public:
	void getdata() {   //получить данные от пользователя		
		cout << "\nвведите имя: "; cin>>name;
		cout << "введите номер: "; cin >> number;
	}
	void putdata() {   //вывод данных
		cout << "\nИмя: " << name;
		cout << "\nНомер: " << number;
	}
};
//number 3
class Distance { //класс  английских расстояний	
private:
	int feet;
	float inches;
public:
	Distance() {  //конструктор (без аргументов)			
		feet = 0; inches = 0;
	}
	Distance(int ft, float in) {//конструктор (2 аргумента)			
		feet = ft; inches = in;
	}
	void getdist() {        //получить расстояние от пользователя
		cout << "\nвведите футы: "; cin >> feet;
		cout << "введите дюймы: "; cin >> inches;
	}
	void showdist() {  //вывод расстояния			
		cout << feet << "'-" << inches << '"';
	}
	//сложение расстояний d2 и d3
	void add_dist(Distance d2, Distance d3) {
		inches = d2.inches + d3.inches; //сложить дюймы
		feet = 0;                      //(для возможного переноса)
		if (inches >= 12.0) {            //если сумма превышает 12.0, уменьшить число дюймов
			inches -= 12.0;              //на 12.0 и
			feet++;                     //увеличить число футов на 1
		}
		feet += d2.feet + d3.feet;      //сложить футы
	};//объявления
	//деление объекта Distance на целое число
	void div_dist(Distance d2, int divisor) {
		float fltfeet = d2.feet + d2.inches / 12.0;//преобразовать в формат float
		fltfeet /= divisor;                     //выполнить деление
		feet = int(fltfeet);              //получить футовую часть
		inches = (fltfeet - feet) * 12.0;     //получить дюймовую часть
	}
};
//number 4
void maxint(int arr[], int n) {
	int max = 0;
	for (int j = 1; j < n; j++) {
		if (arr[j] > arr[max]) { max = j; }
	}
	cout << "Максимальный элемент массива: " << arr[max];
};
//number 5
class fraction {
private:
	int n1, n2;
public:
	char a = '/';
	fraction() {
		n1 = 0;
		n2 = 1;
	}
	void getFrac() {
		cout << "Введите числитель/знаменатель дроби: ";
		cin >> n1 >> a >> n2;
	}
	void putFrac() {
		if (n2 == 1) cout << "Среднее значение " << n1;
		else cout << "Среднее значение " << n1 << '/' << n2 << endl;
	}
	void lowterms() //Сокращение дроби
	{
		long tchis, tznam, temp, nod;
		tchis = labs(n1); // Используем неотрицательные значения | labs - вычисляет абсолютную величину значения, 
		//передаваемого в качестве аргумента через параметр n.
		tznam = labs(n2); // Нужен cmath
		if (tznam == 0) { // Проверка знаменателя 
			cout << "Недопустимый знаменатель"; exit(1); // exit - завершает работу программы
		}
		else if (tchis == 0) {
			n1 = 0;
			n2 = 1;
			return;
		}
		// Нахождение наибольшего общего делителя 
		while (tchis != 0) {
			if (tchis < tznam) { // Если числитель больше знаменателя, меняем их местами.
				temp = tchis;
				tchis = tznam;
				tznam = temp;
			}
			tchis = tchis - tznam;
		}
		nod = tznam;// Делим числитель и знаменатель на НОД.
		n1 = n1 / nod;
		n2 = n2 / nod;
	}
	void div_dist(fraction mas, int n) {
		fraction temp;
		temp.n1 = n;
		temp.n2 = 1;
		n1 = mas.n1 * temp.n2;
		n2 = mas.n2 * temp.n1;
	}
	void fAdd(fraction a) {
		n1 = n1 * a.n2 + a.n1*n2;//числитель
		n2 = n2*a.n2;//знаменатель
	}
	void avarage(int n) {
		n2 *= n;
	}
};
//number 6
enum Suit { clubs, diamonds, hearts, spades };
//от 2 до 10 простые карты
const int jack = 11;
const int queen = 12;
const int king = 13;
const int ace = 14;
class Card {
private:
	int number;
	Suit suit;
public:
	Card() { number = 1; suit = clubs; };
	void SeT(int n, Suit s) {
		suit = s; number = n;
	}
	void display() {
		if (number >= 2 && number <= 10) cout << number;
		else {
			switch (number) {
			case jack: cout << 'J'; break;
			case queen: cout << 'Q'; break;
			case king: cout << 'K'; break;
			case ace: cout << 'A'; break;
			}
		}
		switch (suit) {
		case clubs: cout << static_cast<char>(5); break;
		case diamonds: cout << static_cast<char>(4); break;
		case hearts: cout << static_cast<char>(3); break;
		case spades: cout << static_cast<char>(6); break;
		}
	}
};
//number 7
class money {
private:
	long double number;
public:
	void mstold() {
		char a[100], b[100];
		cout << "Введите денежную сумму: ";
		cin.ignore();
		cin.get(a, 100);
		int j = 0;
		for (int i = 1; i < 100; i++) {
			if (a[i] != '.' && a[i] != ' ') {
				b[j] = a[i];
				j++;
			}
		}
		number = atof(b);
	}
	void display() {
		cout << "$" << number;
	}
};
//number 8
const int LIMIT = 10;
class safeArray {
private: 
	int arr[LIMIT];
public:
	void putel(int index, int zanchenie) {
		if (index < LIMIT - 1 && index>=0) {
			arr[index] = zanchenie;
		}
	}
	void getel(int index) {
		if (index < LIMIT && index>=0) {
			cout << arr[index];
		}
	}
};
//number 9
class queue
{
	static const int MAX = 10;
	int Que[MAX];
	int head, tail;
public:
	queue() { 
		head = MAX, tail = -1; 
	}
	void put(int temp)
	{
		Que[++tail] = temp;
		if (tail == MAX - 1)
			tail = -1;
	}
	void get()
	{
		if (head == 0)
			head = MAX;
		cout << Que[MAX - head--] << endl; //с каждым вызовом head уменьшается
	}
};
//number 10
class matrix {
private:
	int arr[LIMIT][LIMIT];
public:
	matrix(int a, int b) { arr[a][b]; }
	void putel(int ind1, int ind2, int zanchenie) {
		if ((ind1 < LIMIT - 1 && ind1 >= 0)&&(ind2 < LIMIT - 1 && ind2 >= 0)) {
			arr[ind1][ind2] = zanchenie;
		}
	}
	void getel(int ind1, int ind2) {
		if ((ind1 < LIMIT - 1 && ind1 >= 0) && (ind2 < LIMIT - 1 && ind2 >= 0)) {
			cout << arr[ind1][ind2];
		}
	}
};
//number 11
class money2 {
	long double number;
	string ustring;
public:
	void ldtoms() {//double -> string
		cout << "Введите денежную сумму: ";
		cin >> number;
		if (number < 9999999.00) {
			ustring = to_string(number);
			int zero = ustring.size()-1;
			if (ustring.find('.')) zero = ustring.find('.');
			for (zero = zero - 3; zero > 0; zero -= 3)
				ustring.insert(zero, ",");
			ustring = "$" + ustring;
			cout << ustring << endl;
		}
	}
};
//number 12
class bMoney {
private:
	long double money;
	string ustring;
public:
	bMoney() {
		money = 0;
	};
	void mstold() {//string to double
		ustring.erase(ustring.begin());
		int n = ustring.size();
		for (int i = 0; i < n;) {
			if (ustring.at(i) == ',') ustring.erase(ustring.begin() + i,
				ustring.begin() + i + 1);
			else i++;
		}
		money = atof(ustring.c_str());
		/*char a[100], b[100];
		cout << "Введите денежную сумму: ";
		cin.ignore();
		cin.get(ustring, 100);
		int j = 0;
		for (int i = 1; i < 100; i++) {
			if (a[i] != '.' && a[i] != ' ') {
				b[j] = a[i];
				j++;
			}
		}
		number = atof(b);*/
	}
	void ldtoms() {//double to string
		if (money < 9999999.00) {
			ustring = to_string(money);
			int zero = ustring.size() - 1;
			if (ustring.find('.')) zero = ustring.find('.');
			for (zero = zero - 3; zero > 0; zero -= 3)
				ustring.insert(zero, ",");
			ustring = "$" + ustring;
		}
		else cout << "Слишком большое число";
	}
	void madd(bMoney m1, bMoney m2) {
		money = m1.money + m2.money;
	};
	void getmoney() {
		cout << "Введите денежную сумму со знаком $: ";
		cin >> ustring;
	};
	void putmoney() {
		cout << ustring;
	};
};

int main() {
	setlocale(LC_ALL, "Russian");
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	int a;
	cout << "Введите номер лабораторной работы 6: "; cin >> a;
	switch (a)
	{
	case 12: {
		/*Создайте класс bMoney. Он должен хранить денежные значения как long double. Используйте метод mstold() для преобразования 
		денежной строки, введенной пользователем, в long double, и метод ldtoms() для преобразования числа типа long double в денежную 
		строку для вывода (см. задания 7 и 11). Вы можете вызывать для ввода и вывода методы getmoney()и putmoney(). Напишите другой 
		метод класса для сложения двух объектов типа ЬМопеу и назовите его madd(). Сложение этих объектов легко произвести: просто 
		сложите переменную типа long double одного объекта с такой же переменной другого объекта. Напишите функцию main(), которая 
		просит пользователя несколько раз ввести денежную строку, а затем выводит сумму значений этих строк. Вот как может выглядеть 
		определение класса:
		class bMoney {
			private: 
				long double money;
			public:
				bMoney();
				bMoney(char s[]);
				void madd(bMoney m1, bMoneym2);
				void getmoney();
				void putmoney();
		}*/
		bMoney m1, m2, m;
		m1.getmoney();
		m1.mstold();
		m2.getmoney();
		m2.mstold();
		m.madd(m1, m2);
		m.ldtoms();
		m.putmoney();

	}break;
	case 1: {
		/*Напишите функцию reversit(), которая переворачивает строку (массив типа char). Используйте цикл for,
		который меняет местами первый и последний символы, затем следующие и т.д. до предпоследнего.
		Строка должна передаваться в функцию reversit() как аргумент.
		Напишите программу для выполнения функции reversit(). Программа должна принимать строку от пользователя,
		вызывать функцию reversit(), а затем выводить полученный результат. Используйте метод ввода, который позволяет
		использовать внутренние пробелы. Протестируйте программу на примере фразы «Аргентина манит негра».*/
		void reversit(char[]);  //прототип
		const int MAX = 80;         //размер массива
		char str[MAX];            //строка
		cout << "\nвведите строку: ";//получить строку от
		cin.ignore();
		cin.get(str, MAX);//пользователя
		reversit(str);             //перевернуть строку
		cout << "Перевернутая строка:";//и вывести ее
		cout << str << endl;
	}break;
	case 2: {
		/*Создайте класс employee, который содержит имя (объект класса string) и номер (тина long) служащего.
		Включите в него метод getdata(), предназначенный для получения данных от пользователя и помещения их в объект,
		и метод putdata(), для вывода данных. Предполагаем, что имя может иметь внутренние пробелы.

		Напишите функцию main(), использующую этот класс. Вам нужно будет создать массив типа employee, а затем
		предложить пользователю ввести данные до 100 служащих. Наконец, вам нужно будет вывести данные всех служащих. */

		employee emparr[100]; //массив типа employee
		int n = 0;              //количество работников
		char ch;               //ответ пользователя
		do {                   //получить данные от пользователя
			cout << "\nвведите данные о работнике " << n + 1;
			emparr[n++].getdata();
			cout << "Продолжить (y/n)?"; cin >> ch;
		} while (ch != 'n');
		for (int j = 0; j < n; j++) {  //вывести данные из массива
			cout << "\nРаботник " << j + 1;
			emparr[j].putdata();
		}
	}break;
	case 3: {
		/* Напишите программу, вычисляющую среднее значение 100 интервалов, введенных пользователем.
		Создайте массив объектов класса Distance, как это было сделано в примере ENGLARAY этой главы.
		Для вычисления среднего значения вы можете позаимствовать метод add_dist() из примера EN6LC0N главы 5.
		Вам также понадобится метод, который выделяет целую часть из значения Distance. Вот одна из возможностей: */

		Distance distarr[100];       //массив из 100 объектов типа Distance
		Distance total(0, 0.0), average;// прочие расстояния
		int count = 0;        //считает количество введенных значений
		char ch;             //признак ответа пользователя
		do {
			cout << "\nвведите расстояние "; //получить значения
			distarr[count++].getdist();    //от оператора,занести
			cout << "\nПродолжить (y/n)? ";   //их в массив
			cin >> ch;
		} while (ch != 'n');

		for (int j = 0; j < count; j++)  //сложить все расстояния
			total.add_dist(total, distarr[j]); //в total
		average.div_dist(total, count);      //разделить на число
		cout << "\nСреднее: ";     //вывести среднее значение
		average.showdist();
		cout << endl;
	}break;
	case 4: {
		/* Начните с программы, которая позволяет пользователю вводить целые числа, а затем сохранять их в массиве типа int.
		Напишите функцию maxint(), которая, обрабатывая элементы массива один за другим, находит наибольший.
		Функция должна принимать в качестве аргумента адрес массива и количество элементов в нем, а возвращать индекс
		наибольшего элемента. Программа должна вызвать эту функцию, а затем вывести наибольший элемент и его индекс.*/
		const int MAX = 100;
		int arr[MAX];
		int n = 0;
		char ch;
		do {
			cout << "Введите элемент массива: "; cin >> arr[n];
			n++;
			cout << "Продолжить (y/n)? ";
			cin >> ch;
		} while (ch != 'n');
		maxint(arr, n);
	}break;
	case 5: {
		/*Начните с класса fraction из упражнений 11 и 12 лабораторной работы 5. Напишите функцию main(), которая получает
		случайные дробные числа от пользователя, сохраняет их в массиве типа fraction, вычисляет среднее значение и выводит
		результат.*/
		fraction arr[100], sum;
		int n = 0;
		char ch;
		do {
			arr[n++].getFrac();
			cout << "Продолжить (y/n)? ";
			cin >> ch;
		} while (ch != 'n');
		for (int j = 0; j < n; j++) sum.fAdd(arr[j]);
		sum.avarage(n);
		sum.lowterms();
		sum.putFrac();

	}break;
	case 6: {
		/*В игре бридж каждому из игроков раздают 13 карт, таким образом колода расходуется полностью.
		Модифицируйте программу CARDARAY этой главы так, чтобы после перемешивания колоды она делилась на четыре части
		по 13 карт каждая. Каждая из четырех групп карт затем должна быть выведена.*/
		Card deck[52];
		int j;
		for (j = 0; j < 52; j++) {
			int num = (j % 13) + 2;
			Suit su = Suit(j / 13);
			deck[j].SeT(num, su);
		}
		//показываем исходную коллоду
		cout << "Исходная колода\n";
		for (j = 0; j < 52; j++) {
			deck[j].display();
			cout << "  ";
			if (!((j + 1) % 13)) cout << endl;
		}
		srand(time(NULL));
		for (j = 0; j < 52; j++) {
			int k = rand() % 52;
			Card temp = deck[j];
			deck[j] = deck[k];
			deck[k] = temp;
		}
		//показываем перемешанную колоду
		cout << "Перемешанная колода\n";
		for (j = 0; j < 52; j++) {
			deck[j].display();
			cout << "  ";
			if (!((j + 1) % 13))cout << endl;
		}
	}break;
	case 7: {
		/*Одним из недостатков C++ является отсутствие бизнес-программ встроенного типа для денежных значений, такого,
		как $173 698 001,32. Такой денежный тип должен иметь возможность для хранения числа с фиксированной десятичной
		точкой точностью около 17 знаков, которого было бы достаточно для хранения национального долга в долларах и центах.
		К счастью, встроенный тип C++ long double имеет точность 19 цифр, поэтому мы можем использовать его как базисный
		для класса money, даже используя плавающую точку. Однако нам нужно будет добавить возможность ввода и вывода
		денежных значений с предшествующим им знаком доллара и разделенными запятыми группы по три числа: так проще
		читать большие числа. Первым делом при разработке такого класса напишем метод mstold(), который принимает денежную
		строку, то есть строку, представляющую собой некоторое количество денег типа  “$123.456.789.00” в качестве аргумента
		и возвращает эквивалентное ее значению число типа long double.
		Вам нужно будет обработать денежную строку как массив символов и, просматривая ее символ за символом,
		скопировать из нее только цифры (0-9) и десятичную точку в другую строку. Игнорируется все остальное,
		включая знак доллара и запятые. Затем вы можете использовать библиотечную функцию _atold() (заметим, что здесь
		название функции начинается с символа подчеркивания — заголовочные файлы STDLIB.H или МАТН.Н) для преобразования
		новой строки к числу типа long double. Предполагаем, что денежное значение не может быть отрицательным.
		Напишите функцию main() для проверки метода mstold(), которая несколько раз получает денежную строку от
		пользователя и выводит соответствующее число типа long double.*/
		money d;
		d.mstold();
		d.display();

	}break;
	case 8: {
		/*Другим недостатком C++ является отсутствие автоматической проверки индексов массива на соответствие их границам массива
		(это делает действия с массивами быстрыми, но менее надежными). Мы можем использовать класс для создания надежного массива,
		который проверяет индексы при любой попытке доступа к массиву. Напишите класс safearay, который использует массив типа int
		фиксированного размера (назовем его LIMIT) в качестве своей единственной переменной. В классе будет два метода. Первый, putel(),
		принимает индекс и значение типа int как аргументы и вставляет это значение в массив по заданному индексу. Второй, getel(),
		принимает индекс как аргумент и возвращает значение типа int, содержащееся в элементе с этим индексом.
		safearay sal:	//	описываем массив
		int temp = 12345:	//	описываем целое
		sal.putel (7, temp );	//	помещаем значение	temp в массив
		temp = sal.getel(7.4)://	получаем значение из массива
		Оба метода должны проверять индекс аргумента, чтобы быть уверенными, что он не меньше 0 и не больше, чем LIMIT—1.
		Вы можете использовать этот массив без опаски, что запись будет произведена в другие части памяти. Использование методов для
		доступа к элементам массива не выглядит так наглядно, как использование операции [ ]. В главе 8 мы увидим, как перегрузить эту
		операцию, чтобы сделать работу нашего класса safearay похожей на работу встроенных массивов.*/
		safeArray array;
		array.putel(2, 123);
		array.getel(2);
	}break;
	case 9: {
		/* Очередь — это устройство для хранения данных, похожее на стек. Отличие в том, что в стеке последний сохраненный элемент
		будет первым извлеченным, тогда как в очереди первый сохраненный элемент будет первым извлеченным. То есть в стеке используется
		подход «последний вошел — первый вышел» (LJFO), а в очереди используется подход «первый вошел — первый вышел» (FIFO).
		Очередь похожа на простую очередь посетителей магазина: первый, кто встал в очередь, будет обслужен первым.
		Перепишите программу STAKARAY из этой главы, включив в нее класс queue вместо класса stack. Кроме того, класс
		должен иметь два метода: один, называемый put(), для помещения элемента в очередь; и другой, называемый get(),
		для извлечения элемента из очереди. Эти методы эквивалентны методам push() и рор() класса stack.
			Оба класса, stack и queue, используют массив для хранения данных. Однако вместо одного поля top типа int, как в классе stack,
		вам понадобятся два поля для очереди: одна, называемая head, указывающая на начало очереди; и вторая, tail, указывающая на конец
		очереди. Элементы помещаются в конец очереди (как посетители банка, становящиеся в очередь), а извлекаются из начала очереди.
		Конец очереди перемещается к началу по массиву по мере того, как элементы добавляются и извлекаются из очереди.
		Такие результаты добавляют сложности: если одна из двух переменных head или tail примут значение конца массива,
		то следует вернуться на начало. Таким образом, вам нужно выражение типа
		if ( tail == MAX - 1 ) { tail = -1 };
		для возврата переменной tail и похожее выражение для возврата переменной head. Массив, используемый в очереди,
		иногда называют круговым буфером, так как начало и конец очереди циркулируют по нему вместе с ее данными.*/
		queue ura;
		ura.put(13);
		ura.put(21);
		ura.put(45);
		ura.get();
		ura.get();
		ura.get();
	}break;
	case 10: {
		/*Матрица — это двумерный массив. Создайте класс matrix, который предоставляет те же меры безопасности, как и класс из задания 7,
		то есть осуществляет проверку индексов массива на вхождение их в границы массива. Полем класса matrix будет массив 10 на 10.
		Конструктор должен позволять программисту определить реальный размер массива (допустим, сделать его меньше, чем 10 на 10).
		Методам, предназначенным для доступа к членам матрицы, теперь нужны два индекса: но одному для каждой размерности массива.
		Вот фрагмент функции main(), которая работает с таким классом:
		matrix ml(3,4); // Описываем матрицу
		int temp = 12345; // Описываем целое
		ml.putel(4, 4, temp); // Помещаем значение
		temp = ml.getel(7,4); // Получаем значение из матрицы*/

		matrix ml(3, 4);
		int temp = 12345;
		ml.putel(4, 4, temp);
		ml.getel(4, 4);
	}break; 
	case 11: {
		/*Вернемся к обсуждению денежных строк из упражнения 7. Напишите метод ldtoms() для преобразования числа типа long double в
		денежную строку, представляющую это число.
		Для начала вам нужно проверить, что значение long double не очень большое.
		Мы предполагаем, что вы не будете пытаться преобразовать число, больше чем 9 999 999 999 999 990.00. Затем преобразуем
		long double в строку (без знака доллара и запятых), хранящуюся в памяти, используя объект ostrstream, как рассматривалось
		ранее в этой главе. Получившаяся отформатированная строка может быть помещена в буфер, называющийся ustring.
				Затем вам нужно будет создать другую строку, начинающуюся со знака доллара, далее копируем цифру за цифрой из строки ustring,
		начиная слева и вставляя запятые через каждые три цифры. Также вам нужно подавлять нули в начале строки. Например,
		вы должны вывести $3 124.95, а не $0 000 000 000 003 124.95. Не забудьте закончить строку нулевым символом '\0'.
		Напишите функцию main() для тестирования этой функции путем многократного ввода пользователем чисел типа long double и
		вывода результата в виде денежной строки.*/
		money2 a;
		a.ldtoms();
	}break;
	}
}